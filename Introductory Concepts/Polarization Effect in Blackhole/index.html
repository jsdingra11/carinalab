<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Black Hole Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #ffffff; /* Classic XP blue background */
            color: #000;
            font-family: 'Tahoma', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #main-container {
            width: 95vw;
            height: 90vh;
            background-color: #ECE9D8;
            border: 1px solid #003C74;
            border-top: 1px solid #769bce;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }
        #header {
            background-image: linear-gradient(to bottom, #0055E7, #0048D4);
            color: white;
            padding: 5px 10px;
            font-size: 1em;
            font-weight: bold;
            text-shadow: 1px 1px #000;
            display: flex;
            align-items: center;
            justify-content: space-between; /* Aligns items to ends */
            height: 25px;
        }
        #simulation-wrapper {
            position: relative;
            flex-grow: 1;
            background-color: #00000a;
            border: 1px solid #808080;
            border-top: 1px solid #fff;
            margin: 3px;
        }
        canvas {
            display: block;
        }
        #info-panel {
            position: absolute;
            top: 15px;
            right: 15px;
            background-color: #ECE9D8;
            color: #000;
            padding: 15px;
            border-radius: 0;
            border: 1px solid #808080;
            border-top: 1px solid #fff;
            width: 260px;
            box-shadow: 1px 1px 1px rgba(0,0,0,0.2);
        }
        #info-panel h2 {
            margin-top: 0;
            font-size: 1em;
            border-bottom: 1px solid #ccc;
            padding-bottom: 8px;
            margin-bottom: 15px;
        }
        .slider-container {
            margin-bottom: 15px;
        }
        .slider-container label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.9em;
        }
        .slider-container input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 15px;
            background: transparent;
            outline: none;
        }
        .slider-container input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #fff;
            border: 1px solid #808080;
        }
        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            border: 1px solid #003C74;
            height: 21px;
            width: 11px;
            background: #d4d0c8;
            background-image: linear-gradient(to bottom, #f0f0f0, #d4d0c8);
            cursor: pointer;
            margin-top: -9px; 
        }
        .label {
            position: absolute;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
            user-select: none;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            z-index: 10;
        }
        #polarized-view {
            position: absolute;
            bottom: 15px;
            right: 15px;
            width: 180px;
            height: 180px;
            background: #000;
            border: 1px solid #808080;
            border-top: 1px solid #fff;
            overflow: hidden;
        }
        #polarized-canvas {
            width: 100%;
            height: 100%;
        }
        #polarized-view-label {
            position: absolute;
            top: 5px;
            left: 10px;
            color: white;
            font-size: 12px;
            background: rgba(0,0,0,0.5);
            padding: 2px 5px;
            border-radius: 3px;
        }
        #help-button {
            width: 75px;
            height: 23px;
            font-family: 'Tahoma', sans-serif;
            font-size: 11px;
            background: #ECE9D8;
            border: 1px solid #808080;
            border-top-color: #fff;
            border-left-color: #fff;
            box-shadow: 1px 1px 1px #000;
            cursor: pointer;
        }
        #help-button:active {
            border: 1px solid #fff;
            border-top-color: #808080;
            border-left-color: #808080;
            box-shadow: inset 1px 1px 1px #000;
        }
        #popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        #popup-window {
            width: 500px;
            background: #ECE9D8;
            border: 1px solid #003C74;
            border-top: 1px solid #769bce;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            border-radius: 6px;
            overflow: hidden;
        }
        #popup-header {
            background-image: linear-gradient(to bottom, #0055E7, #0048D4);
            color: white;
            padding: 5px 10px;
            font-weight: bold;
            text-shadow: 1px 1px #000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 25px;
        }
        #popup-close-button {
            width: 18px;
            height: 18px;
            background: #d4d0c8;
            border: 1px solid #808080;
            border-top-color: #fff;
            border-left-color: #fff;
            box-shadow: 1px 1px 1px #000;
            color: #000;
            font-weight: bold;
            text-align: center;
            line-height: 16px;
            cursor: pointer;
        }
        #popup-content {
            padding: 15px;
            max-height: 60vh;
            overflow-y: auto;
        }
        #popup-content h3 {
            margin-top: 0;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
        }
    </style>
</head>
<body>
    <div id="main-container">
        <div id="header">
            <span>Polarised Effect of Magnetic Field of Black Hole Plasma</span>
            <button id="help-button">About</button>
        </div>
        <div id="simulation-wrapper">
            <div id="info-panel">
                <h2>Simulation Controls</h2>
                <div class="slider-container">
                    <label for="mass-slider">Mass (spacetime curvature)</label>
                    <input type="range" id="mass-slider" min="5" max="50" value="20" step="1">
                </div>
                <div class="slider-container">
                    <label for="spin-slider">Spin (frame-dragging)</label>
                    <input type="range" id="spin-slider" min="0" max="100" value="50" step="1">
                </div>
            </div>

            <div id="polarized-view">
                <div id="polarized-view-label">Polarized Light View (EHT)</div>
                <canvas id="polarized-canvas"></canvas>
            </div>

            <div class="label" id="label-event-horizon">Event Horizon</div>
            <div class="label" id="label-accretion-disk">Accretion Disk</div>
            <div class="label" id="label-magnetic-field">Magnetic Field</div>
            <div class="label" id="label-spacetime">Spacetime Fabric</div>
        </div>
    </div>

    <div id="popup-overlay">
        <div id="popup-window">
            <div id="popup-header">
                <span>Simulation Help</span>
                <div id="popup-close-button">X</div>
            </div>
            <div id="popup-content">
                <h3>Concepts and Phenomena</h3>
                <p><strong>Event Horizon:</strong> This is the "point of no return" around a black hole. It's not a physical surface, but a boundary in spacetime. Anything that crosses the event horizon, including light, cannot escape the black hole's gravitational pull. In the simulation, it is represented by the central black sphere.</p>
                
                <p><strong>Accretion Disk:</strong> The glowing, turbulent disk of gas and dust that orbits the black hole. As matter gets closer, it speeds up and heats up due to friction, causing it to glow intensely. The brightness is not uniform; the side of the disk moving towards the observer appears brighter (Doppler beaming).</p>
                
                <p><strong>Spacetime Fabric:</strong> According to Einstein's theory of General Relativity, massive objects warp or curve the fabric of spacetime around them. This curvature is what we perceive as gravity. The simulation shows this as a "gravitational well," where the grid is bent downwards by the black hole's mass.</p>
                
                <p><strong>Gravitational Lensing:</strong> The black hole's immense gravity bends the path of light. This is why you can see a bright ring warping over the top and bottom of the black holeâ€”it's the light from the far side of the accretion disk being bent into our line of sight.</p>
                
                <p><strong>Magnetic Fields & Polarization:</strong> The accretion disk generates powerful, twisted magnetic fields. These fields align light waves in a specific pattern, a property called polarization. The "Polarized Light View" simulates how telescopes like the EHT can map these magnetic fields by observing the polarized light, which appears as swirling patterns.</p>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- Basic Scene Setup ---
        const wrapper = document.getElementById('simulation-wrapper');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, wrapper.clientWidth / wrapper.clientHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(wrapper.clientWidth, wrapper.clientHeight);
        wrapper.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 30;
        controls.maxDistance = 300;

        camera.position.set(20, 35, 60);
        camera.lookAt(scene.position);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);

        // --- 2D Spacetime Grid ---
        const gridSize = 250;
        const gridDivisions = 100;
        const gridGeometry = new THREE.PlaneGeometry(gridSize, gridSize, gridDivisions, gridDivisions);
        const gridMaterial = new THREE.MeshBasicMaterial({
            color: 0x888888,
            wireframe: true,
            transparent: true,
            opacity: 0.5
        });
        const spacetimeGrid = new THREE.Mesh(gridGeometry, gridMaterial);
        spacetimeGrid.rotation.x = -Math.PI / 2;
        spacetimeGrid.name = "spacetime";
        scene.add(spacetimeGrid);
        const originalVertices = spacetimeGrid.geometry.attributes.position.array.slice();

        // --- Black Hole ---
        const bhGeometry = new THREE.SphereGeometry(3.5, 64, 64);
        const bhMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const blackHole = new THREE.Mesh(bhGeometry, bhMaterial);
        blackHole.name = "event-horizon";
        scene.add(blackHole);
        
        // --- Realistic Accretion Disk ---
        const diskGeometry = new THREE.RingGeometry(4, 20, 128, 8);
        const diskMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0.0 },
                spin: { value: 0.5 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                varying vec2 vUv;
                uniform float time;
                uniform float spin;

                // 2D Noise function
                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
                }

                float noise(vec2 st) {
                    vec2 i = floor(st);
                    vec2 f = fract(st);
                    float a = random(i);
                    float b = random(i + vec2(1.0, 0.0));
                    float c = random(i + vec2(0.0, 1.0));
                    float d = random(i + vec2(1.0, 1.0));
                    vec2 u = f * f * (3.0 - 2.0 * f);
                    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
                }

                void main() {
                    vec2 centeredUv = vUv - 0.5;
                    float r = length(centeredUv) * 2.0; // Radius from 0 to 1
                    float angle = atan(centeredUv.y, centeredUv.x);

                    // Swirling noise for texture
                    float swirl = angle + time * 0.2 * (spin + 0.1) / r;
                    vec2 noiseUv = vec2(swirl, r * 2.0);
                    float n = noise(noiseUv * 8.0) * 0.5 + noise(noiseUv * 16.0) * 0.25;

                    // Doppler beaming effect
                    float doppler = (sin(angle - time * 0.5 * (spin + 0.1)) + 1.0) / 2.0;
                    doppler = pow(doppler, 3.0);

                    // Color gradient
                    vec3 color = mix(vec3(1.0, 0.3, 0.0), vec3(1.0, 0.8, 0.0), n);
                    color *= doppler * 2.0 + 0.5;

                    // Fade out at edges
                    float alpha = smoothstep(0.0, 0.2, r) * (1.0 - smoothstep(0.9, 1.0, r));
                    
                    gl_FragColor = vec4(color, alpha);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide
        });
        const accretionDisk = new THREE.Mesh(diskGeometry, diskMaterial);
        accretionDisk.rotation.x = -Math.PI / 2;
        accretionDisk.name = "accretion-disk";
        scene.add(accretionDisk);

        // --- Gravitational Lensing Effect ---
        const lensedDisk = accretionDisk.clone();
        lensedDisk.name = "accretion-disk";
        lensedDisk.material = accretionDisk.material.clone();
        lensedDisk.material.uniforms = THREE.UniformsUtils.clone(accretionDisk.material.uniforms);
        lensedDisk.material.vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                vec3 pos = position;
                float r = length(pos.xy);
                // Bend the top and bottom of the ring upwards/downwards
                pos.z += (pos.y > 0.0 ? 1.0 : -1.0) * 5.0 * smoothstep(4.0, 10.0, r);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;
        scene.add(lensedDisk);

        // --- Photon Sphere ---
        const photonSphereGeom = new THREE.TorusGeometry(3.6, 0.1, 16, 128);
        const photonSphereMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 });
        const photonSphere = new THREE.Mesh(photonSphereGeom, photonSphereMat);
        photonSphere.rotation.x = Math.PI / 2;
        scene.add(photonSphere);

        // --- Magnetic Field Lines ---
        const magneticFieldGroup = new THREE.Group();
        magneticFieldGroup.name = "magnetic-field";
        const fieldLineMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.7 });
        for (let i = 0; i < 10; i++) {
            const angle = (i / 10) * Math.PI * 2;
            const path = new THREE.CatmullRomCurve3([ new THREE.Vector3(Math.cos(angle) * 4, -30, Math.sin(angle) * 4), new THREE.Vector3(Math.cos(angle) * 6, -10, Math.sin(angle) * 6), new THREE.Vector3(Math.cos(angle) * 8, 0, Math.sin(angle) * 8), new THREE.Vector3(Math.cos(angle) * 6, 10, Math.sin(angle) * 6), new THREE.Vector3(Math.cos(angle) * 4, 30, Math.sin(angle) * 4) ]);
            const tubeGeometry = new THREE.TubeGeometry(path, 64, 0.15, 8, false);
            const fieldLine = new THREE.Mesh(tubeGeometry, fieldLineMaterial);
            magneticFieldGroup.add(fieldLine);
        }
        scene.add(magneticFieldGroup);

        // --- Photon Particles ---
        const photonGroup = new THREE.Group();
        const photonMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const photonGeometry = new THREE.SphereGeometry(0.3, 8, 8);
        const photons = [];
        scene.add(photonGroup);

        function spawnPhoton() {
            const photon = new THREE.Mesh(photonGeometry, photonMaterial);
            const radius = 150;
            const angle = Math.random() * Math.PI * 2;
            photon.position.set(Math.cos(angle) * radius, (Math.random() - 0.5) * 50, Math.sin(angle) * radius);
            const velocity = new THREE.Vector3().sub(photon.position).normalize().multiplyScalar(-2);
            velocity.y += (Math.random() - 0.5) * 0.2;
            photon.userData.velocity = velocity;
            photons.push(photon);
            photonGroup.add(photon);
        }

        // --- Starfield ---
        const starGeometry = new THREE.BufferGeometry();
        const starVertices = [];
        for (let i = 0; i < 15000; i++) {
            const x = (Math.random() - 0.5) * 2000;
            const y = (Math.random() - 0.5) * 2000;
            const z = (Math.random() - 0.5) * 2000;
            const dist = Math.sqrt(x*x + y*y + z*z);
            if(dist > 400) starVertices.push(x, y, z);
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.8 });
        const starfield = new THREE.Points(starGeometry, starMaterial);
        scene.add(starfield);

        // --- UI Controls & Labels ---
        const massSlider = document.getElementById('mass-slider');
        const spinSlider = document.getElementById('spin-slider');
        let blackHoleMass = parseFloat(massSlider.value);
        let blackHoleSpin = parseFloat(spinSlider.value);
        massSlider.addEventListener('input', e => blackHoleMass = parseFloat(e.target.value));
        spinSlider.addEventListener('input', e => blackHoleSpin = parseFloat(e.target.value));

        const labels = {
            'event-horizon': document.getElementById('label-event-horizon'),
            'accretion-disk': document.getElementById('label-accretion-disk'),
            'magnetic-field': document.getElementById('label-magnetic-field'),
            'spacetime': document.getElementById('label-spacetime')
        };
        const labelPositions = {
            'event-horizon': new THREE.Vector3(4, 2, 0),
            'accretion-disk': new THREE.Vector3(12, 2, 0),
            'magnetic-field': new THREE.Vector3(0, 15, 6),
            'spacetime': new THREE.Vector3(30, -10, 30)
        };

        // --- Raycaster for Hover ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        function onMouseMove(event) {
            const rect = wrapper.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }
        window.addEventListener('mousemove', onMouseMove, false);

        // --- Polarized View Canvas ---
        const polarCanvas = document.getElementById('polarized-canvas');
        const polarCtx = polarCanvas.getContext('2d');
        polarCanvas.width = 180; polarCanvas.height = 180;

        function drawPolarizedView(time) {
            const w = polarCanvas.width, h = polarCanvas.height, cx = w / 2, cy = h / 2;
            const spinEffect = blackHoleSpin / 100.0;
            const shadowRadius = 15 + (blackHoleMass - 5) * (20 / 45);
            polarCtx.clearRect(0, 0, w, h);
            polarCtx.fillStyle = 'black';
            polarCtx.beginPath();
            polarCtx.arc(cx, cy, shadowRadius, 0, Math.PI * 2);
            polarCtx.fill();
            
            const lines = 36;
            for (let i = 0; i < lines; i++) {
                const angle = (i / lines) * Math.PI * 2;
                const brightness = Math.sin(angle + time * 2) * 0.4 + 0.6;
                polarCtx.strokeStyle = `rgba(255, ${165 * brightness}, 0, ${brightness * 0.8})`;
                polarCtx.lineWidth = 1 + brightness * 2;
                
                const radius = shadowRadius + 15 + Math.sin(angle * 3 + time) * 8;
                
                const startX = cx + Math.cos(angle) * radius, startY = cy + Math.sin(angle) * radius;
                const swirlAngle = angle + Math.PI / 2 + spinEffect * Math.sin(angle * 2 + time * 3) * 0.5;
                const endX = startX + Math.cos(swirlAngle) * 12 * brightness, endY = startY + Math.sin(swirlAngle) * 12 * brightness;
                polarCtx.beginPath();
                polarCtx.moveTo(startX, startY);
                polarCtx.lineTo(endX, endY);
                polarCtx.stroke();
            }
        }
        
        // --- Popup Logic ---
        const helpButton = document.getElementById('help-button');
        const popupOverlay = document.getElementById('popup-overlay');
        const popupCloseButton = document.getElementById('popup-close-button');

        helpButton.addEventListener('click', () => {
            popupOverlay.style.display = 'flex';
        });

        popupCloseButton.addEventListener('click', () => {
            popupOverlay.style.display = 'none';
        });

        // --- Animation Loop ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            const deltaTime = clock.getDelta();

            // --- Update Spacetime ---
            const vertices = spacetimeGrid.geometry.attributes.position.array;
            const spinFactor = blackHoleSpin / 100.0;
            for (let i = 0; i < vertices.length; i += 3) {
                const x = originalVertices[i], y = originalVertices[i + 1];
                const distance = Math.sqrt(x * x + y * y);
                let z = 0;
                if (distance > 0.1) {
                    const effectRadius = 40;
                    z = -blackHoleMass * 2.5 * Math.exp(-(distance * distance) / (2 * effectRadius * effectRadius));
                }
                vertices[i + 2] = z;
                if (distance < 80) {
                    const angle = Math.atan2(y, x);
                    const twistAngle = (spinFactor * 100 / (distance + 20)) * (Math.PI / 180);
                    vertices[i] = Math.cos(angle + twistAngle) * distance;
                    vertices[i + 1] = Math.sin(angle + twistAngle) * distance;
                } else {
                    vertices[i] = originalVertices[i];
                    vertices[i + 1] = originalVertices[i + 1];
                }
            }
            spacetimeGrid.geometry.attributes.position.needsUpdate = true;

            // --- Update Photons ---
            if (Math.random() > 0.95) spawnPhoton();
            for (let i = photons.length - 1; i >= 0; i--) {
                const photon = photons[i];
                const p = photon.position;
                const distSq = p.lengthSq();
                const gravity = new THREE.Vector3().copy(p).normalize().multiplyScalar(-blackHoleMass * 500 / (distSq + 100));
                photon.userData.velocity.add(gravity.multiplyScalar(deltaTime));
                p.add(photon.userData.velocity.clone().multiplyScalar(deltaTime * 10));
                if (distSq < 10 || distSq > 250 * 250) {
                    photonGroup.remove(photon);
                    photons.splice(i, 1);
                }
            }
            
            // --- Update Objects ---
            accretionDisk.material.uniforms.time.value = elapsedTime;
            accretionDisk.material.uniforms.spin.value = spinFactor;
            lensedDisk.material.uniforms.time.value = elapsedTime;
            lensedDisk.material.uniforms.spin.value = spinFactor;
            magneticFieldGroup.rotation.y += 0.002 * (spinFactor + 0.1);
            
            // --- Update Labels on Hover ---
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([blackHole, accretionDisk, lensedDisk, ...magneticFieldGroup.children, spacetimeGrid], true);
            
            let currentHover = null;
            if (intersects.length > 0) {
                let obj = intersects[0].object;
                if (obj.parent === magneticFieldGroup) obj = magneticFieldGroup;
                if(obj.name === "" && obj.parent && obj.parent.name === "accretion-disk") obj = obj.parent;
                currentHover = obj.name;
            }

            for (const name in labels) {
                const labelElement = labels[name];
                if (labelElement) { // CORRECTED: Check if label element exists
                    if (name === currentHover) {
                        labelElement.style.opacity = '1';
                        const pos = labelPositions[name];
                        const vector = pos.clone().project(camera);
                        const rect = wrapper.getBoundingClientRect();
                        const x = ((vector.x * 0.5 + 0.5) * rect.width);
                        const y = ((vector.y * -0.5 + 0.5) * rect.height);
                        labelElement.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
                        if (!labelElement.parentNode) {
                           wrapper.appendChild(labelElement);
                        }
                    } else {
                        labelElement.style.opacity = '0';
                    }
                }
            }

            // --- Render ---
            drawPolarizedView(elapsedTime);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // --- Handle Window Resize ---
        window.addEventListener('resize', () => {
            camera.aspect = wrapper.clientWidth / wrapper.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(wrapper.clientWidth, wrapper.clientHeight);
        });

        // Helper function for smoothstep
        function smoothstep(min, max, value) {
            const x = Math.max(0, Math.min(1, (value - min) / (max - min)));
            return x * x * (3 - 2 * x);
        }
    </script>
</body>
</html>
